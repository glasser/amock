=== src/java/edu/mit/csail/pag/amock/tests/HierarchyTests.java
==================================================================
--- src/java/edu/mit/csail/pag/amock/tests/HierarchyTests.java	(revision 153280)
+++ src/java/edu/mit/csail/pag/amock/tests/HierarchyTests.java	(local)
@@ -74,4 +74,7 @@
         assertThat(mgc("Grandkid", "I1", "I2", "java/lang/Object"), is("I1"));
     }
 
+    public void testJDK() {
+        assertThat(mgc("java/util/HashMap", "java/util/Map"), is("java/util/Map"));
+    }
 }
=== src/java/edu/mit/csail/pag/amock/trace/Hierarchy.java
==================================================================
--- src/java/edu/mit/csail/pag/amock/trace/Hierarchy.java	(revision 153280)
+++ src/java/edu/mit/csail/pag/amock/trace/Hierarchy.java	(local)
@@ -59,10 +59,42 @@
         Map<ClassName, HierarchyEntry> entriesByName
             = new HashMap<ClassName, HierarchyEntry>();
 
+        // These are the ones we know we need to deal with but haven't
+        // yet.
+        Set<ClassName> pendingNames = new HashSet<ClassName>();
+        Queue<HierarchyEntry> pending = new LinkedList<HierarchyEntry>();
         for (HierarchyEntry he : entries) {
-            entriesByName.put(he.className, he);
+            pending.offer(he);
+            pendingNames.add(he.className);
         }
 
+        while (! pending.isEmpty()) {
+            assert pending.size() == pendingNames.size();
+
+            HierarchyEntry next = pending.remove();
+            pendingNames.remove(next.className);
+            entriesByName.put(next.className, next);
+
+            for (ClassName someSuper : next.allSupers()) {
+                if (entriesByName.containsKey(someSuper)
+                    || pendingNames.contains(someSuper)) {
+                    continue;
+                }
+
+                if (Premain.shouldTransform(someSuper)) {
+                    continue;
+                }
+
+                // Aha!  It's probably some sort of JDK class or
+                // something!  Get its HierarchyEntry using
+                // reflection.
+                HierarchyEntry superEntry
+                    = HierarchyEntry.createWithReflection(someSuper);
+                pending.offer(superEntry);
+                pendingNames.add(superEntry.className);
+            }
+        }
+
         return entriesByName;
     }
 
=== src/java/edu/mit/csail/pag/amock/trace/HierarchyEntry.java
==================================================================
--- src/java/edu/mit/csail/pag/amock/trace/HierarchyEntry.java	(revision 153280)
+++ src/java/edu/mit/csail/pag/amock/trace/HierarchyEntry.java	(local)
@@ -1,7 +1,7 @@
 package edu.mit.csail.pag.amock.trace;
 
 import java.io.Serializable;
-
+import java.util.*;
 import edu.mit.csail.pag.amock.util.ClassName;
 
 public class HierarchyEntry implements Serializable {
@@ -34,4 +34,32 @@
                                   cifs,
                                   isPublic);
     }
+
+    public Collection<ClassName> allSupers() {
+        Collection<ClassName> all = new ArrayList<ClassName>();
+        all.add(superName);
+        all.addAll(Arrays.asList(interfaces));
+        return all;
+    }
+
+    // Only call this on code (JDK, etc) that you're comfortable
+    // loading at processor-time!
+    public static HierarchyEntry createWithReflection(ClassName name) {
+        Class<?> cls = Class.forName(name.asClassForNameArgument());
+
+        Class<?> superCls = cls.getSuperClass();
+        ClassName superName
+            = ClassName.fromDotted( superCls == null
+                                    ? "java.lang.Object"
+                                    : superCls.getName() );
+
+        Class[] ifClasses = cls.getInterfaces();
+        ClassName[] ifNames = new ClassName[ifClasses.length];
+
+        for (int i = 0; i < ifClasses.length; i++) {
+            ifNames[i] = ClassName.fromDotted(ifClasses[i].getName());
+        }
+
+        return new HierarchyEntry(name, superName, ifNames, PUBLIC);
+    }
 }
